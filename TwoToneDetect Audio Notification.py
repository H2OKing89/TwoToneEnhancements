# -----------------------------------------------------------------------------
# Script Information
# -----------------------------------------------------------------------------
# Script Name: TwoToneDetect Audio Notification
# Version: v1.7.0
# Author: Quentin King
# Date: 08-28-2024
# Description: This script processes an audio file generated by Two-Tone Detect (TTD),
#              uploads it to an FTP server, and sends a webhook to Node-RED with the 
#              audio file URL and relevant details. Includes error handling, detailed 
#              logging, and exponential backoff for retrying webhooks. Configuration 
#              settings are loaded from a shared INI file. Now includes log rotation,
#              Pushover notifications for critical errors, graceful shutdown handling,
#              and unit tests.
# Changelog:
# - v1.7.0: Updated to read from separate config.ini, ftp.ini, and pushover.ini files.
#           Sensitive data moved to credentials.ini. Enhanced logging with relative paths.
# - v1.6.2: Added unit tests for FTP connections and webhook notifications, enforced HTTPS
#           for webhook URLs, and enhanced error logging with additional details.
# - v1.6.1: Added unit tests, retry mechanism with configurable backoff strategy,
#           enhanced error handling, and updated log levels.
# - v1.6.0: Added log rotation, Pushover notifications for errors, and graceful shutdown handling.
# - v1.5.0: Updated log file naming convention, added detailed comments and docstrings,
#           improved error handling and retry mechanism.
# - v1.4.0: Implemented configuration via config.ini, integrated Pushover notifications, 
#           and enhanced logging for argument-related issues.
# - v1.3.0: Added detailed error handling for FTP connections and webhook requests.
# - v1.2.0: Integrated FTP and webhook functionality, added logging and retry mechanism.
# - v1.1.0: Initial release with basic FTP upload and webhook notification.
# -----------------------------------------------------------------------------

import os
import logging
import sys
import requests
from ftplib import FTP, error_perm, error_temp
import configparser
from logging.handlers import RotatingFileHandler
from time import sleep
import signal
import random

# -----------------------------------------------------------------------------
# Configuration
# -----------------------------------------------------------------------------
# Load configuration from the ini files
config = configparser.ConfigParser()

# Assuming all INI files are in the same directory as this script
script_dir = os.path.dirname(os.path.abspath(__file__))

# Load config.ini, ftp.ini, and pushover.ini
config.read([
    os.path.join(script_dir, 'config.ini'),
    os.path.join(script_dir, 'ftp.ini'),
    os.path.join(script_dir, 'pushover.ini')
])

# FTP server details
ftp_server = config.get('FTP', 'FTP_SERVER')
ftp_port = int(config.get('FTP', 'FTP_PORT'))
ftp_user = config.get('FTP', 'FTP_USER')
ftp_pass = config.get('FTP', 'FTP_PASS')

if not ftp_user or not ftp_pass:
    raise EnvironmentError("FTP credentials are not set. Please ensure FTP_USER and FTP_PASS are provided in the configuration files.")

# Webhook details
webhook_url = config.get('Webhook', 'ttd_audio_received_url')
tone_detected_url = config.get('Webhook', 'tone_detected_url')
base_audio_url = config.get('Webhook', 'base_audio_url')

# Pushover details
pushover_token = config.get('Pushover', 'PUSHOVER_TOKEN')
pushover_user = config.get('Pushover', 'PUSHOVER_USER')

# Backoff strategy configuration
backoff_strategy = config.get('Retries', 'backoff_strategy', fallback='exponential')
max_retries = int(config.get('Retries', 'max_retries'))
retry_delay = int(config.get('Retries', 'retry_delay'))

# Set up logging with rotation
log_directory = os.path.join(script_dir, config['Logging']['log_dir'])
cleanup_days = int(config['Logging']['cleanup_days'])

if not os.path.exists(log_directory):
    os.makedirs(log_directory)

log_file = os.path.join(log_directory, 'ttd_audio_notification.log')
logging.basicConfig(
    handlers=[RotatingFileHandler(log_file, maxBytes=1048576, backupCount=5)],
    level=config.get('Logging', 'log_level', fallback='INFO').upper(),
    format='%(asctime)s - %(levelname)s - %(message)s'
)

# -----------------------------------------------------------------------------
# Function: send_webhook
# Description: Sends a webhook to Node-RED with retry mechanism and tailored 
#              exception handling. Uses a configurable backoff strategy for retries.
# -----------------------------------------------------------------------------
def send_webhook(file_name, topic, retries=max_retries):
    """
    Sends a webhook to Node-RED with the audio file URL and relevant details.

    This function attempts to send a webhook with the specified audio file and 
    topic. If the request fails, it retries up to the specified number of times, 
    using a configurable backoff strategy.

    Args:
        file_name (str): The name of the audio file to be included in the webhook.
        topic (str): The topic for the webhook and notification.
        retries (int): Number of retry attempts for sending the webhook (default is max_retries).

    Returns:
        bool: True if the webhook was sent successfully, False otherwise.
    """
    if not webhook_url.startswith("https://"):
        logging.error("Webhook URL is not secure. HTTPS is required.")
        raise ValueError("Webhook URL must start with https://")

    file_name = os.path.basename(file_name)
    file_url = f"{base_audio_url}{file_name}"
    
    payload = {
        "payload": {
            "message": file_url,
            "title": f"{topic} Audio Uploaded",
            "topic": topic
        }
    }

    attempt = 0
    delay = retry_delay

    while attempt < retries:
        try:
            response = requests.post(webhook_url, json=payload)
            response.raise_for_status()
            logging.info(f"Webhook sent successfully: {payload}")
            return True
        
        except requests.exceptions.ConnectionError as conn_err:
            logging.warning(f"Attempt {attempt + 1}: Connection Error: {conn_err}")
            send_pushover_notification(f"Connection error: {conn_err}", f"Attempt {attempt + 1}")

        except requests.exceptions.Timeout as timeout_err:
            logging.warning(f"Attempt {attempt + 1}: Timeout Error: {timeout_err}")
            send_pushover_notification(f"Timeout error: {timeout_err}", f"Attempt {attempt + 1}")

        except requests.exceptions.HTTPError as http_err:
            logging.error(f"Attempt {attempt + 1}: HTTP Error: {http_err}")
            send_pushover_notification(f"HTTP error: {http_err}", f"Attempt {attempt + 1}")

        except requests.exceptions.RequestException as req_err:
            logging.error(f"Attempt {attempt + 1}: General Webhook Error: {req_err}")
            send_pushover_notification(f"General error: {req_err}", f"Attempt {attempt + 1}")

        attempt += 1
        delay = calculate_backoff_delay(attempt)

        if attempt < retries:
            logging.info(f"Retrying in {delay} seconds... ({attempt}/{retries})")
            sleep(delay)

    logging.error(f"Webhook failed after {retries} attempts.")
    send_pushover_notification(f"Webhook failed after {retries} attempts.")
    return False

# -----------------------------------------------------------------------------
# Function: calculate_backoff_delay
# Description: Calculates the delay based on the selected backoff strategy.
# -----------------------------------------------------------------------------
def calculate_backoff_delay(attempt):
    """
    Calculates the delay based on the selected backoff strategy.

    Args:
        attempt (int): The current retry attempt number.

    Returns:
        int: The delay in seconds for the next retry.
    """
    if backoff_strategy == 'linear':
        return retry_delay * attempt
    elif backoff_strategy == 'exponential':
        return retry_delay * (2 ** (attempt - 1))
    elif backoff_strategy == 'jitter':
        return random.uniform(0, retry_delay * (2 ** (attempt - 1)))
    else:
        return retry_delay  # Default to fixed delay

# -----------------------------------------------------------------------------
# Function: send_pushover_notification
# Description: Sends a notification to Pushover in case of critical errors.
# -----------------------------------------------------------------------------
def send_pushover_notification(message, additional_info=None):
    """
    Sends a Pushover notification for critical errors with additional context.

    Args:
        message (str): The error message to be sent via Pushover.
        additional_info (str, optional): Additional context or details about the error.

    Returns:
        None
    """
    pushover_url = "https://api.pushover.net/1/messages.json"
    full_message = f"{message}\nDetails: {additional_info}" if additional_info else message
    payload = {
        "token": pushover_token,
        "user": pushover_user,
        "message": full_message,
        "title": "TwoToneDetect Error",
        "priority": 1
    }
    try:
        response = requests.post(pushover_url, data=payload)
        response.raise_for_status()
        logging.info("Pushover notification sent successfully.")
    except requests.exceptions.RequestException as e:
        logging.error(f"Failed to send Pushover notification: {e}")

# -----------------------------------------------------------------------------
# Function: graceful_shutdown
# Description: Handles graceful shutdown by sending a final alert and performing cleanup.
# -----------------------------------------------------------------------------
def graceful_shutdown(signal_received, frame):
    """
    Handles graceful shutdown when an interrupt signal is received.

    This function ensures that the script completes any ongoing operations and 
    sends a final notification before exiting.

    Args:
        signal_received (int): The signal number received.
        frame: The current stack frame.

    Returns:
        None
    """
    logging.info("Graceful shutdown initiated.")
    send_pushover_notification("Script is shutting down gracefully.")
    sys.exit(0)

# -----------------------------------------------------------------------------
# Function: connect_to_ftp
# Description: Establishes a connection to the FTP server.
# Returns: FTP object if the connection is successful, None otherwise.
# -----------------------------------------------------------------------------
def connect_to_ftp():
    """
    Establishes a connection to the FTP server.

    This function attempts to connect to the specified FTP server using the 
    credentials provided in the environment variables or config.ini file.

    Returns:
        FTP: An FTP object if the connection is successful, None otherwise.
    """
    try:
        ftp = FTP()
        ftp.connect(ftp_server, ftp_port)
        ftp.login(ftp_user, ftp_pass)
        logging.info(f"Connected to FTP server {ftp_server}:{ftp_port}")
        return ftp
    except (error_perm, error_temp) as ftp_error:
        logging.error(f"FTP error: {ftp_error}")
        send_pushover_notification(f"FTP error: {ftp_error}")
        return None
    except Exception as e:
        logging.error(f"Unexpected error: {e}")
        send_pushover_notification(f"Unexpected FTP connection error: {e}")
        return None

# -----------------------------------------------------------------------------
# Function: store_file
# Description: Uploads the audio file to the FTP server and sends a webhook.
# -----------------------------------------------------------------------------
def store_file(ftp, local_file, department):
    """
    Uploads the audio file to the FTP server and sends a webhook notification.

    Args:
        ftp (FTP): An active FTP connection object.
        local_file (str): The local path to the audio file to be uploaded.
        department (str): The department or topic associated with the file.

    Returns:
        None
    """
    try:
        file_name = os.path.basename(local_file)
        with open(local_file, 'rb') as f:
            logging.debug(f"Uploading file: {file_name}")
            ftp.storbinary(f'STOR {file_name}', f)
            logging.info(f"Uploaded {file_name} to FTP server")
            send_webhook(file_name, department)  # Send webhook after upload
    except Exception as e:
        logging.error(f"Failed to upload to FTP server: {e}")
        send_pushover_notification(f"Failed to upload to FTP server: {e}")

# -----------------------------------------------------------------------------
# Function: upload_to_ftp
# Description: Connects to the FTP server and uploads the file.
# -----------------------------------------------------------------------------
def upload_to_ftp(local_file, department):
    """
    Connects to the FTP server and uploads the specified audio file.

    This function handles the entire process of connecting to the FTP server 
    and uploading the audio file. It also triggers the webhook notification 
    after the upload is complete.

    Args:
        local_file (str): The local path to the audio file to be uploaded.
        department (str): The department or topic associated with the file.

    Returns:
        None
    """
    ftp = connect_to_ftp()
    if ftp:
        store_file(ftp, local_file, department)
        ftp.quit()

# -----------------------------------------------------------------------------
# Main Execution
# -----------------------------------------------------------------------------
def main():
    """
    Main function to process the audio file and handle errors.

    This function processes the command-line arguments, verifies the audio file 
    exists, and initiates the FTP upload and webhook notification process.
    """
    try:
        # Handle graceful shutdown on interrupt signals
        signal.signal(signal.SIGINT, graceful_shutdown)
        signal.signal(signal.SIGTERM, graceful_shutdown)

        # Log the arguments passed to the script
        logging.debug(f"Arguments passed to the script: {sys.argv}")

        if len(sys.argv) != 3:
            raise ValueError(f"Incorrect number of arguments passed to the script. Expected 3, got {len(sys.argv)}. Arguments: {sys.argv}")

        mp3_file = sys.argv[1]
        department = sys.argv[2]
        logging.info(f"Processing file: {mp3_file} for department: {department}")

        if os.path.isfile(mp3_file):
            upload_to_ftp(mp3_file, department)
        else:
            raise FileNotFoundError(f"File not found: {mp3_file}")

    except ValueError as ve:
        logging.error(f"ValueError encountered: {ve}")
        send_pushover_notification(f"ValueError encountered: {ve}")
    except FileNotFoundError as fnf_error:
        logging.error(f"FileNotFoundError encountered: {fnf_error}")
        send_pushover_notification(f"FileNotFoundError encountered: {fnf_error}")
    except Exception as e:
        logging.error(f"Unexpected error encountered: {e}")
        send_pushover_notification(f"Unexpected error encountered: {e}")

if __name__ == "__main__":
    main()
