import os
import sys
import logging
import requests
import random  # Importing random module for the jitter backoff strategy
import psutil  # Importing psutil for resource usage tracking
from ftplib import FTP, error_perm, error_temp  # Importing FTP-related classes and exceptions
import configparser
from time import sleep, time
from datetime import datetime
from dotenv import load_dotenv

# -----------------------------------------------------------------------------
# Script Information
# -----------------------------------------------------------------------------
# Script Name: ttd_audio_notification.py
# Version: v2.1.0
# Author: Quentin King
# Date: 09-01-2024
# Description: Processes audio files generated by Two-Tone Detect (TTD), uploads
#              them to an FTP server, and sends a webhook to Node-RED. Includes 
#              enhanced error handling, detailed logging, performance monitoring, 
#              modular structure, and support for environment variables.
# Changelog:
# - v2.1.0: Moved sensitive credentials to environment variables, enhanced logging,
#           added performance monitoring, and refactored error handling.
# - v2.0.0: Refactored script for modularity, added performance monitoring,
#           enhanced error handling, and improved documentation.
# - v1.0.3: Added log cleanup functionality based on log count and age.
# - v1.0.2: Fixed ValueError from inline comments in config.ini and updated log filename format.
# - v1.0.1: Added import for `random` module and updated error handling.
# - v1.0.0: Initial creation with logging, FTP upload, and webhook functionality.
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# Load Environment Variables
# -----------------------------------------------------------------------------
load_dotenv()

# -----------------------------------------------------------------------------
# Configuration
# -----------------------------------------------------------------------------
# Get the directory where the script is located
script_dir = os.path.dirname(os.path.abspath(__file__))

# Define paths to the config.ini file
config_path = os.path.join(script_dir, 'config.ini')

# Load configuration from the config.ini file
config = configparser.ConfigParser()
config.read([config_path])

# Access the Logging configuration
log_dir = os.path.join(script_dir, config['ttd_audio_notification_Logging']['log_dir'])
log_level = config['ttd_audio_notification_Logging']['log_level']
max_logs = int(config['ttd_audio_notification_Logging']['max_logs'])
max_log_days = int(config['ttd_audio_notification_Logging']['max_log_days'])
log_to_console = config.getboolean('ttd_audio_notification_Logging', 'log_to_console')

# Access the FTP credentials and settings from environment variables
ftp_server = os.getenv('FTP_SERVER')
ftp_port = int(os.getenv('FTP_PORT'))
ftp_user = os.getenv('FTP_USER')
ftp_pass = os.getenv('FTP_PASS')

# Access the Webhook and base audio URL
webhook_url = config['ttd_audio_notification_Webhook']['ttd_audio_received_url']
base_audio_url = config['ttd_audio_notification_Webhook']['base_audio_url']
timeout_seconds = int(config['ttd_audio_notification_Webhook']['timeout_seconds'])  # Now correctly parsed as an integer

# Access the Pushover credentials and settings from environment variables
pushover_token = os.getenv('PUSHOVER_TOKEN')
pushover_user_key = os.getenv('PUSHOVER_USER')
pushover_priority = int(config['ttd_audio_notification_Pushover']['priority'])
pushover_retry = int(config['ttd_audio_notification_Pushover']['retry'])
pushover_expire = int(config['ttd_audio_notification_Pushover']['expire'])
pushover_sound = config['ttd_audio_notification_Pushover']['sound']

# Access the Retry logic settings
max_retries = int(config['ttd_audio_notification_Retry']['max_retries'])
retry_delay = int(config['ttd_audio_notification_Retry']['retry_delay'])
backoff_strategy = config['ttd_audio_notification_Retry']['backoff_strategy']

# Access the Base Path for Audio Files
base_path = config['ttd_audio_notification_Path']['base_path']

# Access the File Handling settings
temp_directory = os.path.join(script_dir, config['ttd_audio_notification_FileHandling']['temp_directory'])

# Ensure the log directory exists
if not os.path.exists(log_dir):
    os.makedirs(log_dir)

# Configure logging
log_file_name = f"ftp_upload_{datetime.now().strftime('%m-%d-%Y_%H-%M-%S')}.log"
log_file_path = os.path.join(log_dir, log_file_name)

logging.basicConfig(
    filename=log_file_path,
    level=getattr(logging, log_level.upper(), logging.DEBUG),
    format='%(asctime)s - %(levelname)s - %(message)s'
)

if log_to_console:
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(getattr(logging, log_level.upper(), logging.DEBUG))
    console_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
    logging.getLogger().addHandler(console_handler)

logging.info("Logging initialized.")
logging.info(f"Logs will be stored in: {log_dir}")
logging.info(f"Log file: {log_file_name}")

# Ensure the temp directory exists
if not os.path.exists(temp_directory):
    os.makedirs(temp_directory)

logging.debug(f"Temporary files will be stored in: {temp_directory}")
logging.debug(f"Base path for audio files: {base_path}")

# -----------------------------------------------------------------------------
# Log Cleanup Function
# -----------------------------------------------------------------------------
def cleanup_logs():
    logging.debug("Entered cleanup_logs function.")
    now = datetime.now().timestamp()
    logs = []
    deleted_files_count = 0

    for filename in os.listdir(log_dir):
        file_path = os.path.join(log_dir, filename)
        if os.path.isfile(file_path):
            file_age = now - os.path.getmtime(file_path)
            logs.append((file_path, file_age))

    logs.sort(key=lambda x: x[1])

    for log_file, file_age in logs:
        if file_age > max_log_days * 86400:
            try:
                os.remove(log_file)
                logging.info(f"Deleted old log file: {os.path.basename(log_file)}")
                deleted_files_count += 1
            except PermissionError:
                logging.warning(f"Could not delete {os.path.basename(log_file)} as it is in use.")
    
    while len(logs) > max_logs:
        log_file, _ = logs.pop(0)
        try:
            os.remove(log_file)
            logging.info(f"Deleted excess log file: {os.path.basename(log_file)}")
            deleted_files_count += 1
        except PermissionError:
            logging.warning(f"Could not delete {os.path.basename(log_file)} as it is in use.")
    
    if deleted_files_count == 0:
        logging.info("No old or excess log files were found for deletion.")
    else:
        logging.info(f"Deleted {deleted_files_count} old or excess log file(s).")
    
    logging.debug("Exiting cleanup_logs function.")

# Clean up logs before starting the main functionality
cleanup_logs()

# -----------------------------------------------------------------------------
# Custom Exceptions
# -----------------------------------------------------------------------------
class FTPConnectionError(Exception):
    pass

class FileUploadError(Exception):
    pass

class WebhookError(Exception):
    pass

# -----------------------------------------------------------------------------
# Function: performance_monitor
# -----------------------------------------------------------------------------
def performance_monitor():
    logging.info(f"Memory Usage: {psutil.virtual_memory().percent}%")
    logging.info(f"CPU Usage: {psutil.cpu_percent()}%")

# -----------------------------------------------------------------------------
# Function: send_webhook
# -----------------------------------------------------------------------------
def send_webhook(file_name, topic, retries=max_retries):
    file_name = os.path.basename(file_name)
    file_url = f"{base_audio_url}{file_name}"
    
    payload = {
        "payload": {
            "message": file_url,
            "title": f"{topic} Audio Uploaded",
            "topic": topic
        }
    }

    attempt = 0
    delay = retry_delay

    while attempt < retries:
        try:
            response = requests.post(webhook_url, json=payload, timeout=timeout_seconds)
            response.raise_for_status()
            logging.info(f"Webhook sent successfully: {payload}")
            return True
        
        except requests.exceptions.RequestException as e:
            logging.warning(f"Attempt {attempt + 1} failed: {e}")
            send_pushover_notification(f"Webhook error: {e}", f"Attempt {attempt + 1}")

        attempt += 1
        delay = calculate_retry_delay(attempt)

        if attempt < retries:
            logging.info(f"Retrying in {delay} seconds... ({attempt}/{retries})")
            sleep(delay)

    logging.error(f"Webhook failed after {retries} attempts.")
    send_pushover_notification(f"Webhook failed after {retries} attempts.")
    raise WebhookError(f"Webhook failed after {retries} attempts.")

# -----------------------------------------------------------------------------
# Function: calculate_retry_delay
# -----------------------------------------------------------------------------
def calculate_retry_delay(attempt):
    if backoff_strategy == 'linear':
        return retry_delay * attempt
    elif backoff_strategy == 'exponential':
        return retry_delay * (2 ** (attempt - 1))
    elif backoff_strategy == 'jitter':
        return random.uniform(0, retry_delay * (2 ** (attempt - 1)))
    else:
        return retry_delay

# -----------------------------------------------------------------------------
# Function: send_pushover_notification
# -----------------------------------------------------------------------------
def send_pushover_notification(message, additional_info=None):
    pushover_url = "https://api.pushover.net/1/messages.json"
    full_message = f"{message}\nDetails: {additional_info}" if additional_info else message
    payload = {
        "token": pushover_token,
        "user": pushover_user_key,
        "message": full_message,
        "title": "TwoToneDetect Error",
        "priority": pushover_priority,
        "retry": pushover_retry,
        "expire": pushover_expire,
        "sound": pushover_sound
    }
    try:
        response = requests.post(pushover_url, data=payload)
        response.raise_for_status()
        logging.info("Pushover notification sent successfully.")
    except requests.exceptions.RequestException as e:
        logging.error(f"Failed to send Pushover notification: {e}")

# -----------------------------------------------------------------------------
# Function: connect_to_ftp
# -----------------------------------------------------------------------------
def connect_to_ftp():
    try:
        ftp = FTP()
        ftp.connect(ftp_server, ftp_port)
        ftp.login(ftp_user, ftp_pass)
        logging.info(f"Connected to FTP server {ftp_server}:{ftp_port}")
        return ftp
    except (error_perm, error_temp) as ftp_error:
        logging.error(f"FTP error: {ftp_error}")
        send_pushover_notification(f"FTP error: {ftp_error}")
        raise FTPConnectionError(f"FTP error: {ftp_error}")
    except Exception as e:
        logging.error(f"Unexpected FTP connection error: {e}")
        send_pushover_notification(f"Unexpected FTP connection error: {e}")
        raise FTPConnectionError(f"Unexpected FTP connection error: {e}")

# -----------------------------------------------------------------------------
# Function: store_file
# -----------------------------------------------------------------------------
def store_file(ftp, local_file, department):
    try:
        file_name = os.path.basename(local_file)
        with open(local_file, 'rb') as f:
            logging.debug(f"Uploading file: {file_name}")
            ftp.storbinary(f'STOR {file_name}', f)
            logging.info(f"Uploaded {file_name} to FTP server")
            send_webhook(file_name, department)
    except Exception as e:
        logging.error(f"Failed to upload to FTP server: {e}")
        send_pushover_notification(f"Failed to upload to FTP server: {e}")
        raise FileUploadError(f"Failed to upload to FTP server: {e}")

# -----------------------------------------------------------------------------
# Function: upload_to_ftp
# -----------------------------------------------------------------------------
def upload_to_ftp(local_file, department):
    ftp = connect_to_ftp()
    if ftp:
        try:
            store_file(ftp, local_file, department)
        finally:
            ftp.quit()
            logging.info("FTP connection closed.")

# -----------------------------------------------------------------------------
# Main Execution
# -----------------------------------------------------------------------------
def main():
    logging.debug("Starting script execution.")
    start_time = time()

    try:
        if len(sys.argv) != 3:
            raise ValueError(f"Incorrect number of arguments passed to the script. Expected 3, got {len(sys.argv)}. Arguments: {sys.argv}")

        mp3_file = os.path.join(base_path, sys.argv[1])
        department = sys.argv[2]
        logging.info(f"Processing file: {mp3_file} for department: {department}")

        if os.path.isfile(mp3_file):
            upload_to_ftp(mp3_file, department)
        else:
            raise FileNotFoundError(f"File not found: {mp3_file}")

    except ValueError as ve:
        logging.error(f"ValueError encountered: {ve}")
        send_pushover_notification(f"ValueError encountered: {ve}")
    except FileNotFoundError as fnf_error:
        logging.error(f"FileNotFoundError encountered: {fnf_error}")
        send_pushover_notification(f"FileNotFoundError encountered: {fnf_error}")
    except FTPConnectionError as ftp_error:
        logging.error(f"FTPConnectionError: {ftp_error}")
    except FileUploadError as file_error:
        logging.error(f"FileUploadError: {file_error}")
    except WebhookError as webhook_error:
        logging.error(f"WebhookError: {webhook_error}")
    except Exception as e:
        logging.error(f"Unexpected error encountered: {e}")
        send_pushover_notification(f"Unexpected error encountered: {e}")
    finally:
        execution_time = time() - start_time
        logging.info(f"Script completed in {execution_time:.2f} seconds.")
        performance_monitor()

if __name__ == "__main__":
    main()
