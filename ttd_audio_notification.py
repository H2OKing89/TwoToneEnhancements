import os
import sys
import logging
import requests
import random  # Importing random module for the jitter backoff strategy
from ftplib import FTP, error_perm, error_temp
import configparser
from time import sleep
from datetime import datetime

# -----------------------------------------------------------------------------
# Script Information
# -----------------------------------------------------------------------------
# Script Name: ttd_audio_notification.py
# Version: v1.0.3
# Author: Quentin King
# Date: 09-01-2024
# Description: This script processes an audio file generated by Two-Tone Detect (TTD),
#              uploads it to an FTP server, and sends a webhook to Node-RED with the 
#              audio file URL and relevant details. Includes error handling, detailed 
#              logging, and exponential backoff for retrying webhooks. Configuration 
#              settings are loaded from a shared INI file.
# Changelog:
# - v1.0.3: Added log cleanup functionality based on log count and age.
# - v1.0.2: Fixed ValueError from inline comments in config.ini and updated log filename format.
# - v1.0.1: Added import for `random` module and updated error handling.
# - v1.0.0: Initial creation with logging, FTP upload, and webhook functionality.
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# Configuration
# -----------------------------------------------------------------------------
# Get the directory where the script is located
script_dir = os.path.dirname(os.path.abspath(__file__))

# Define paths to the config.ini and credentials.ini files
config_path = os.path.join(script_dir, 'config.ini')
credentials_path = os.path.join(script_dir, 'credentials.ini')

# Load configuration from the config.ini and credentials.ini files
config = configparser.ConfigParser()
config.read([config_path, credentials_path])

# Access the Logging configuration
log_dir = os.path.join(script_dir, config['ttd_audio_notification_Logging']['log_dir'])
log_level = config['ttd_audio_notification_Logging']['log_level']
max_logs = int(config['ttd_audio_notification_Logging']['max_logs'])
max_log_days = int(config['ttd_audio_notification_Logging']['max_log_days'])
log_to_console = config.getboolean('ttd_audio_notification_Logging', 'log_to_console')

# Ensure the log directory exists
if not os.path.exists(log_dir):
    os.makedirs(log_dir)

# Configure logging
log_file_name = f"ftp_upload_{datetime.now().strftime('%m-%d-%Y_%H-%M-%S')}.log"
log_file_path = os.path.join(log_dir, log_file_name)

logging.basicConfig(
    filename=log_file_path,
    level=getattr(logging, log_level.upper(), logging.DEBUG),
    format='%(asctime)s - %(levelname)s - %(message)s'
)

if log_to_console:
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(getattr(logging, log_level.upper(), logging.DEBUG))
    console_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
    logging.getLogger().addHandler(console_handler)

logging.info("Logging initialized.")
logging.info(f"Logs will be stored in: {log_dir}")
logging.info(f"Log file: {log_file_name}")

# -----------------------------------------------------------------------------
# Log Cleanup Function
# -----------------------------------------------------------------------------
def cleanup_logs():
    """
    Cleans up old log files in the specified directory that are older than the 
    configured number of days or exceed the configured maximum number of logs.

    This function deletes log files that are older than the 'max_log_days' 
    configuration parameter or if the number of logs exceeds 'max_logs' in the 
    'log_dir' directory.

    Returns:
        None
    """
    logging.debug("Entered cleanup_logs function.")
    now = datetime.now().timestamp()
    logs = []
    deleted_files_count = 0

    for filename in os.listdir(log_dir):
        file_path = os.path.join(log_dir, filename)
        if os.path.isfile(file_path):
            file_age = now - os.path.getmtime(file_path)
            logs.append((file_path, file_age))

    # Sort the logs by age (oldest first)
    logs.sort(key=lambda x: x[1])

    # Delete logs based on age
    for log_file, file_age in logs:
        if file_age > max_log_days * 86400:
            try:
                os.remove(log_file)
                logging.info(f"Deleted old log file: {os.path.basename(log_file)}")
                deleted_files_count += 1
            except PermissionError:
                logging.warning(f"Could not delete {os.path.basename(log_file)} as it is in use.")
    
    # Delete excess logs if the count exceeds max_logs
    while len(logs) > max_logs:
        log_file, _ = logs.pop(0)
        try:
            os.remove(log_file)
            logging.info(f"Deleted excess log file: {os.path.basename(log_file)}")
            deleted_files_count += 1
        except PermissionError:
            logging.warning(f"Could not delete {os.path.basename(log_file)} as it is in use.")
    
    if deleted_files_count == 0:
        logging.info("No old or excess log files were found for deletion.")
    else:
        logging.info(f"Deleted {deleted_files_count} old or excess log file(s).")
    
    logging.debug("Exiting cleanup_logs function.")

# Clean up logs before starting the main functionality
cleanup_logs()

# -----------------------------------------------------------------------------
# Access FTP and other configurations
# -----------------------------------------------------------------------------
# Access the FTP credentials and settings
ftp_server = config['ttd_audio_notification_Credentials']['ftp_server']
ftp_port = int(config['ttd_audio_notification_Credentials']['ftp_port'])
ftp_user = config['ttd_audio_notification_Credentials']['ftp_user']
ftp_pass = config['ttd_audio_notification_Credentials']['ftp_pass']

logging.debug(f"FTP Server: {ftp_server}, Port: {ftp_port}")

# Access the Webhook and base audio URL
webhook_url = config['ttd_audio_notification_Webhook']['ttd_audio_received_url']
base_audio_url = config['ttd_audio_notification_Webhook']['base_audio_url']
timeout_seconds = int(config['ttd_audio_notification_Webhook']['timeout_seconds'])  # Now correctly parsed as an integer

logging.debug(f"Webhook URL: {webhook_url}, Base Audio URL: {base_audio_url}")

# Access the Pushover credentials and settings
pushover_token = config['ttd_audio_notification_Credentials']['pushover_token']
pushover_user_key = config['ttd_audio_notification_Credentials']['pushover_user']
pushover_priority = int(config['ttd_audio_notification_Pushover']['priority'])
pushover_retry = int(config['ttd_audio_notification_Pushover']['retry'])
pushover_expire = int(config['ttd_audio_notification_Pushover']['expire'])
pushover_sound = config['ttd_audio_notification_Pushover']['sound']

logging.debug("Pushover settings loaded.")

# Access the Retry logic settings
max_retries = int(config['ttd_audio_notification_Retry']['max_retries'])
retry_delay = int(config['ttd_audio_notification_Retry']['retry_delay'])
backoff_strategy = config['ttd_audio_notification_Retry']['backoff_strategy']

logging.debug("Retry logic settings loaded.")

# Access the File Handling settings
temp_directory = os.path.join(script_dir, config['ttd_audio_notification_FileHandling']['temp_directory'])

# Ensure the temp directory exists
if not os.path.exists(temp_directory):
    os.makedirs(temp_directory)

logging.debug(f"Temporary files will be stored in: {temp_directory}")

# Access the Base Path for Audio Files
base_path = config['ttd_audio_notification_Path']['base_path']

logging.debug(f"Base path for audio files: {base_path}")

# -----------------------------------------------------------------------------
# Function: send_webhook
# Description: Sends a webhook to Node-RED with retry mechanism and tailored 
#              exception handling. Uses a configurable backoff strategy for retries.
# -----------------------------------------------------------------------------
def send_webhook(file_name, topic, retries=max_retries):
    """
    Sends a webhook to Node-RED with the audio file URL and relevant details.

    This function attempts to send a webhook with the specified audio file and 
    topic. If the request fails, it retries up to the specified number of times, 
    using a configurable backoff strategy.

    Args:
        file_name (str): The name of the audio file to be included in the webhook.
        topic (str): The topic for the webhook and notification.
        retries (int): Number of retry attempts for sending the webhook (default is max_retries).

    Returns:
        bool: True if the webhook was sent successfully, False otherwise.
    """
    file_name = os.path.basename(file_name)
    file_url = f"{base_audio_url}{file_name}"
    
    payload = {
        "payload": {
            "message": file_url,
            "title": f"{topic} Audio Uploaded",
            "topic": topic
        }
    }

    attempt = 0
    delay = retry_delay

    while attempt < retries:
        try:
            response = requests.post(webhook_url, json=payload, timeout=timeout_seconds)
            response.raise_for_status()
            logging.info(f"Webhook sent successfully: {payload}")
            return True
        
        except requests.exceptions.RequestException as e:
            logging.warning(f"Attempt {attempt + 1} failed: {e}")
            send_pushover_notification(f"Webhook error: {e}", f"Attempt {attempt + 1}")

        attempt += 1
        delay = calculate_retry_delay(attempt)

        if attempt < retries:
            logging.info(f"Retrying in {delay} seconds... ({attempt}/{retries})")
            sleep(delay)

    logging.error(f"Webhook failed after {retries} attempts.")
    send_pushover_notification(f"Webhook failed after {retries} attempts.")
    return False

# -----------------------------------------------------------------------------
# Function: calculate_retry_delay
# Description: Calculates the delay based on the selected backoff strategy.
# -----------------------------------------------------------------------------
def calculate_retry_delay(attempt):
    """
    Calculates the delay based on the selected backoff strategy.

    Args:
        attempt (int): The current retry attempt number.

    Returns:
        int: The delay in seconds for the next retry.
    """
    if backoff_strategy == 'linear':
        return retry_delay * attempt
    elif backoff_strategy == 'exponential':
        return retry_delay * (2 ** (attempt - 1))
    elif backoff_strategy == 'jitter':
        return random.uniform(0, retry_delay * (2 ** (attempt - 1)))
    else:
        return retry_delay  # Default to fixed delay

# -----------------------------------------------------------------------------
# Function: send_pushover_notification
# Description: Sends a notification to Pushover in case of critical errors.
# -----------------------------------------------------------------------------
def send_pushover_notification(message, additional_info=None):
    """
    Sends a Pushover notification for critical errors with additional context.

    Args:
        message (str): The error message to be sent via Pushover.
        additional_info (str, optional): Additional context or details about the error.

    Returns:
        None
    """
    pushover_url = "https://api.pushover.net/1/messages.json"
    full_message = f"{message}\nDetails: {additional_info}" if additional_info else message
    payload = {
        "token": pushover_token,
        "user": pushover_user_key,
        "message": full_message,
        "title": "TwoToneDetect Error",
        "priority": pushover_priority,
        "retry": pushover_retry,
        "expire": pushover_expire,
        "sound": pushover_sound
    }
    try:
        response = requests.post(pushover_url, data=payload)
        response.raise_for_status()
        logging.info("Pushover notification sent successfully.")
    except requests.exceptions.RequestException as e:
        logging.error(f"Failed to send Pushover notification: {e}")

# -----------------------------------------------------------------------------
# Function: connect_to_ftp
# Description: Establishes a connection to the FTP server.
# Returns: FTP object if the connection is successful, None otherwise.
# -----------------------------------------------------------------------------
def connect_to_ftp():
    """
    Establishes a connection to the FTP server.

    This function attempts to connect to the specified FTP server using the 
    credentials provided in the configuration file.

    Returns:
        FTP: An FTP object if the connection is successful, None otherwise.
    """
    try:
        ftp = FTP()
        ftp.connect(ftp_server, ftp_port)
        ftp.login(ftp_user, ftp_pass)
        logging.info(f"Connected to FTP server {ftp_server}:{ftp_port}")
        return ftp
    except (error_perm, error_temp) as ftp_error:
        logging.error(f"FTP error: {ftp_error}")
        send_pushover_notification(f"FTP error: {ftp_error}")
        return None
    except Exception as e:
        logging.error(f"Unexpected FTP connection error: {e}")
        send_pushover_notification(f"Unexpected FTP connection error: {e}")
        return None

# -----------------------------------------------------------------------------
# Function: store_file
# Description: Uploads the audio file to the FTP server and sends a webhook.
# -----------------------------------------------------------------------------
def store_file(ftp, local_file, department):
    """
    Uploads the audio file to the FTP server and sends a webhook notification.

    Args:
        ftp (FTP): An active FTP connection object.
        local_file (str): The local path to the audio file to be uploaded.
        department (str): The department or topic associated with the file.

    Returns:
        None
    """
    try:
        file_name = os.path.basename(local_file)
        with open(local_file, 'rb') as f:
            logging.debug(f"Uploading file: {file_name}")
            ftp.storbinary(f'STOR {file_name}', f)
            logging.info(f"Uploaded {file_name} to FTP server")
            send_webhook(file_name, department)  # Send webhook after upload
    except Exception as e:
        logging.error(f"Failed to upload to FTP server: {e}")
        send_pushover_notification(f"Failed to upload to FTP server: {e}")

# -----------------------------------------------------------------------------
# Function: upload_to_ftp
# Description: Connects to the FTP server and uploads the file.
# -----------------------------------------------------------------------------
def upload_to_ftp(local_file, department):
    """
    Connects to the FTP server and uploads the specified audio file.

    This function handles the entire process of connecting to the FTP server 
    and uploading the audio file. It also triggers the webhook notification 
    after the upload is complete.

    Args:
        local_file (str): The local path to the audio file to be uploaded.
        department (str): The department or topic associated with the file.

    Returns:
        None
    """
    ftp = connect_to_ftp()
    if ftp:
        store_file(ftp, local_file, department)
        ftp.quit()
        logging.info("FTP connection closed.")

# -----------------------------------------------------------------------------
# Main Execution
# -----------------------------------------------------------------------------
def main():
    """
    Main function to process the audio file and handle errors.

    This function processes the command-line arguments, verifies the audio file 
    exists, and initiates the FTP upload and webhook notification process.
    """
    logging.debug("Starting script execution.")

    try:
        if len(sys.argv) != 3:
            raise ValueError(f"Incorrect number of arguments passed to the script. Expected 3, got {len(sys.argv)}. Arguments: {sys.argv}")

        mp3_file = os.path.join(base_path, sys.argv[1])
        department = sys.argv[2]
        logging.info(f"Processing file: {mp3_file} for department: {department}")

        if os.path.isfile(mp3_file):
            upload_to_ftp(mp3_file, department)
        else:
            raise FileNotFoundError(f"File not found: {mp3_file}")

    except ValueError as ve:
        logging.error(f"ValueError encountered: {ve}")
        send_pushover_notification(f"ValueError encountered: {ve}")
    except FileNotFoundError as fnf_error:
        logging.error(f"FileNotFoundError encountered: {fnf_error}")
        send_pushover_notification(f"FileNotFoundError encountered: {fnf_error}")
    except Exception as e:
        logging.error(f"Unexpected error encountered: {e}")
        send_pushover_notification(f"Unexpected error encountered: {e}")

if __name__ == "__main__":
    main()
