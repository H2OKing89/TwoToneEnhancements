# -----------------------------------------------------------------------------
# Script Information
# -----------------------------------------------------------------------------
# Script Name: TwoToneDetect Audio Notification
# Version: v1.8.1
# Author: Quentin King
# Date: 08-31-2024
# Description: This script processes an audio file generated by Two-Tone Detect (TTD),
#              uploads it to an FTP server, and sends a webhook to Node-RED with the 
#              audio file URL and relevant details. The script is highly configurable 
#              via external INI files and includes features such as:
#              - Secure handling of sensitive information through credentials.ini
#              - Modular configuration for FTP, webhook, and Pushover settings
#              - Exponential backoff strategy for retrying failed webhook notifications
#              - Advanced Pushover notification options, including priority, sound, 
#                and emergency notification handling
#              - Graceful shutdown handling to ensure proper cleanup on exit
#              - Detailed logging with log rotation and cleanup based on file age
# -----------------------------------------------------------------------------
# Changelog:
# - v1.8.1:
#   - Defined the `script_dir` variable to ensure that the script correctly identifies
#     its directory location. This change allows the script to construct paths relative
#     to its own location, resolving the "script_dir is not defined" error.
# - v1.8.0:
#   - Integrated support for modular INI files (config.ini, ftp.ini, pushover.ini).
#   - Added advanced Pushover notification settings for priority, sound, and emergency
#     notification handling, utilizing credentials stored in credentials.ini.
#   - Removed unnecessary webhook references, focusing exclusively on the 
#     `ttd_audio_received_url` webhook.
# - v1.7.0:
#   - Updated to read from separate config.ini, ftp.ini, and pushover.ini files.
#   - Sensitive data moved to credentials.ini. Enhanced logging with relative paths.
# - v1.6.2:
#   - Added unit tests for FTP connections and webhook notifications, enforced HTTPS
#     for webhook URLs, and enhanced error logging with additional details.
# - v1.6.1:
#   - Added unit tests, retry mechanism with configurable backoff strategy,
#     enhanced error handling, and updated log levels.
# - v1.6.0:
#   - Added log rotation, Pushover notifications for errors, and graceful shutdown handling.
# - v1.5.0:
#   - Updated log file naming convention, added detailed comments and docstrings,
#     improved error handling and retry mechanism.
# - v1.4.0:
#   - Implemented configuration via config.ini, integrated Pushover notifications, 
#     and enhanced logging for argument-related issues.
# - v1.3.0:
#   - Added detailed error handling for FTP connections and webhook requests.
# - v1.2.0:
#   - Integrated FTP and webhook functionality, added logging and retry mechanism.
# - v1.1.0:
#   - Initial release with basic FTP upload and webhook notification.
# -----------------------------------------------------------------------------
# Configuration:
# - `ttd_audio_notification_Webhook` section in config.ini:
#   - `ttd_audio_received_url`: Webhook URL for notifying when an audio file is received.
#   - `base_audio_url`: Base URL for accessing uploaded audio files.
# - `ttd_audio_notification_Retries` section in config.ini:
#   - `backoff_strategy`: Strategy for retrying failed webhook notifications (e.g., exponential).
#   - `max_retries`: Maximum number of retry attempts.
#   - `retry_delay`: Initial delay (in seconds) between retry attempts.
# - `ttd_audio_notification_Logging` section in config.ini:
#   - `log_dir`: Directory where logs will be stored.
#   - `log_level`: Logging level (e.g., INFO, DEBUG).
#   - `cleanup_days`: Number of days after which old log files should be deleted.
# - `ttd_audio_notification_FTP` section in ftp.ini:
#   - `server`: FTP server address.
#   - `port`: FTP server port.
#   - `user`: FTP username.
#   - `pass`: FTP password (resolved from credentials.ini).
# - `ttd_audio_notification_Pushover` section in pushover.ini:
#   - `PUSHOVER_TOKEN`: Pushover API token for sending notifications (resolved from credentials.ini).
#   - `PUSHOVER_USER`: Pushover user key for sending notifications (resolved from credentials.ini).
#   - `priority`: Priority level for Pushover notifications.
#   - `sound`: Notification sound to be used for Pushover notifications.
#   - `expire`: Expiration time for emergency notifications (in seconds).
#   - `retry`: Retry interval for emergency notifications (in seconds).
#   - `ttl`: Time to live (TTL) for the message in seconds.
# -----------------------------------------------------------------------------

import os
import logging
import sys
import requests
from ftplib import FTP, error_perm, error_temp
import configparser
from logging.handlers import RotatingFileHandler
from time import sleep
import signal
import random

# Define script_dir as the directory where the script is located
script_dir = os.path.dirname(os.path.abspath(__file__))

# -----------------------------------------------------------------------------
# Configuration
# -----------------------------------------------------------------------------
# Load configuration from the INI files
config = configparser.ConfigParser()

# Load credentials.ini first to resolve placeholders
credentials = configparser.ConfigParser()
credentials.read('credentials.ini')

# Load config.ini and ftp.ini, resolving placeholders with credentials
config.read_dict(credentials)  # Include credentials
config.read(['config.ini', 'ftp.ini', 'pushover.ini'])

# FTP server details
ftp_server = config.get('ttd_audio_notification_FTP', 'server')
ftp_port = int(config.get('ttd_audio_notification_FTP', 'port'))
ftp_user = config.get('ttd_audio_notification_FTP', 'user')
ftp_pass = config.get('ttd_audio_notification_FTP', 'pass')

# Webhook details
webhook_url = config.get('ttd_audio_notification_Webhook', 'ttd_audio_received_url')
base_audio_url = config.get('ttd_audio_notification_Webhook', 'base_audio_url')

# Pushover details
pushover_token = config.get('ttd_audio_notification_Pushover', 'PUSHOVER_TOKEN')
pushover_user = config.get('ttd_audio_notification_Pushover', 'PUSHOVER_USER')
pushover_priority = int(config.get('ttd_audio_notification_Pushover', 'priority', fallback=1))
pushover_sound = config.get('ttd_audio_notification_Pushover', 'sound', fallback='pushover')
pushover_expire = int(config.get('ttd_audio_notification_Pushover', 'expire', fallback=3600))
pushover_retry = int(config.get('ttd_audio_notification_Pushover', 'retry', fallback=60))
pushover_ttl = int(config.get('ttd_audio_notification_Pushover', 'ttl', fallback=3600))

# Backoff strategy configuration
backoff_strategy = config.get('ttd_audio_notification_Retries', 'backoff_strategy', fallback='exponential')
max_retries = int(config.get('ttd_audio_notification_Retries', 'max_retries'))
retry_delay = int(config.get('ttd_audio_notification_Retries', 'retry_delay'))

# Set up logging with rotation
log_directory = os.path.join(script_dir, config['ttd_audio_notification_Logging']['log_dir'])
cleanup_days = int(config['ttd_audio_notification_Logging']['cleanup_days'])

if not os.path.exists(log_directory):
    os.makedirs(log_directory)

log_file = os.path.join(log_directory, 'ttd_audio_notification.log')
logging.basicConfig(
    handlers=[RotatingFileHandler(log_file, maxBytes=1048576, backupCount=5)],
    level=config.get('ttd_audio_notification_Logging', 'log_level', fallback='INFO').upper(),
    format='%(asctime)s - %(levelname)s - %(message)s'
)

# -----------------------------------------------------------------------------
# Function: send_webhook
# Description: Sends a webhook to Node-RED with retry mechanism and tailored 
#              exception handling. Uses a configurable backoff strategy for retries.
# -----------------------------------------------------------------------------
def send_webhook(file_name, topic, retries=max_retries):
    """
    Sends a webhook to Node-RED with the audio file URL and relevant details.

    This function attempts to send a webhook with the specified audio file and 
    topic. If the request fails, it retries up to the specified number of times, 
    using a configurable backoff strategy.

    Args:
        file_name (str): The name of the audio file to be included in the webhook.
        topic (str): The topic for the webhook and notification.
        retries (int): Number of retry attempts for sending the webhook (default is max_retries).

    Returns:
        bool: True if the webhook was sent successfully, False otherwise.
    """
    if not webhook_url.startswith("https://"):
        logging.error("Webhook URL is not secure. HTTPS is required.")
        raise ValueError("Webhook URL must start with https://")

    file_name = os.path.basename(file_name)
    file_url = f"{base_audio_url}{file_name}"
    
    payload = {
        "payload": {
            "message": file_url,
            "title": f"{topic} Audio Uploaded",
            "topic": topic
        }
    }

    attempt = 0
    delay = retry_delay

    while attempt < retries:
        try:
            response = requests.post(webhook_url, json=payload)
            response.raise_for_status()
            logging.info(f"Webhook sent successfully: {payload}")
            return True
        
        except requests.exceptions.ConnectionError as conn_err:
            logging.warning(f"Attempt {attempt + 1}: Connection Error: {conn_err}")
            send_pushover_notification(f"Connection error: {conn_err}", f"Attempt {attempt + 1}")

        except requests.exceptions.Timeout as timeout_err:
            logging.warning(f"Attempt {attempt + 1}: Timeout Error: {timeout_err}")
            send_pushover_notification(f"Timeout error: {timeout_err}", f"Attempt {attempt + 1}")

        except requests.exceptions.HTTPError as http_err:
            logging.error(f"Attempt {attempt + 1}: HTTP Error: {http_err}")
            send_pushover_notification(f"HTTP error: {http_err}", f"Attempt {attempt + 1}")

        except requests.exceptions.RequestException as req_err:
            logging.error(f"Attempt {attempt + 1}: General Webhook Error: {req_err}")
            send_pushover_notification(f"General error: {req_err}", f"Attempt {attempt + 1}")

        attempt += 1
        delay = calculate_backoff_delay(attempt)

        if attempt < retries:
            logging.info(f"Retrying in {delay} seconds... ({attempt}/{retries})")
            sleep(delay)

    logging.error(f"Webhook failed after {retries} attempts.")
    send_pushover_notification(f"Webhook failed after {retries} attempts.")
    return False

# -----------------------------------------------------------------------------
# Function: calculate_backoff_delay
# Description: Calculates the delay based on the selected backoff strategy.
# -----------------------------------------------------------------------------
def calculate_backoff_delay(attempt):
    """
    Calculates the delay based on the selected backoff strategy.

    Args:
        attempt (int): The current retry attempt number.

    Returns:
        int: The delay in seconds for the next retry.
    """
    if backoff_strategy == 'linear':
        return retry_delay * attempt
    elif backoff_strategy == 'exponential':
        return retry_delay * (2 ** (attempt - 1))
    elif backoff_strategy == 'jitter':
        return random.uniform(0, retry_delay * (2 ** (attempt - 1)))
    else:
        return retry_delay  # Default to fixed delay

# -----------------------------------------------------------------------------
# Function: send_pushover_notification
# Description: Sends a notification to Pushover in case of critical errors.
# -----------------------------------------------------------------------------
def send_pushover_notification(message, additional_info=None):
    """
    Sends a Pushover notification for critical errors with additional context.

    Args:
        message (str): The error message to be sent via Pushover.
        additional_info (str, optional): Additional context or details about the error.

    Returns:
        None
    """
    pushover_url = "https://api.pushover.net/1/messages.json"
    full_message = f"{message}\nDetails: {additional_info}" if additional_info else message
    payload = {
        "token": pushover_token,
        "user": pushover_user,
        "message": full_message,
        "title": "TwoToneDetect Error",
        "priority": pushover_priority,
        "sound": pushover_sound,
        "retry": pushover_retry,
        "expire": pushover_expire,
        "ttl": pushover_ttl
    }
    try:
        response = requests.post(pushover_url, data=payload)
        response.raise_for_status()
        logging.info("Pushover notification sent successfully.")
    except requests.exceptions.RequestException as e:
        logging.error(f"Failed to send Pushover notification: {e}")

# -----------------------------------------------------------------------------
# Function: graceful_shutdown
# Description: Handles graceful shutdown by sending a final alert and performing cleanup.
# -----------------------------------------------------------------------------
def graceful_shutdown(signal_received, frame):
    """
    Handles graceful shutdown when an interrupt signal is received.

    This function ensures that the script completes any ongoing operations and 
    sends a final notification before exiting.

    Args:
        signal_received (int): The signal number received.
        frame: The current stack frame.

    Returns:
        None
    """
    logging.info("Graceful shutdown initiated.")
    send_pushover_notification("Script is shutting down gracefully.")
    sys.exit(0)

# -----------------------------------------------------------------------------
# Function: connect_to_ftp
# Description: Establishes a connection to the FTP server.
# Returns: FTP object if the connection is successful, None otherwise.
# -----------------------------------------------------------------------------
def connect_to_ftp():
    """
    Establishes a connection to the FTP server.

    This function attempts to connect to the specified FTP server using the 
    credentials provided in the environment variables or config.ini file.

    Returns:
        FTP: An FTP object if the connection is successful, None otherwise.
    """
    try:
        ftp = FTP()
        ftp.connect(ftp_server, ftp_port)
        ftp.login(ftp_user, ftp_pass)
        logging.info(f"Connected to FTP server {ftp_server}:{ftp_port}")
        return ftp
    except (error_perm, error_temp) as ftp_error:
        logging.error(f"FTP error: {ftp_error}")
        send_pushover_notification(f"FTP error: {ftp_error}")
        return None
    except Exception as e:
        logging.error(f"Unexpected error: {e}")
        send_pushover_notification(f"Unexpected FTP connection error: {e}")
        return None

# -----------------------------------------------------------------------------
# Function: store_file
# Description: Uploads the audio file to the FTP server and sends a webhook.
# -----------------------------------------------------------------------------
def store_file(ftp, local_file, department):
    """
    Uploads the audio file to the FTP server and sends a webhook notification.

    Args:
        ftp (FTP): An active FTP connection object.
        local_file (str): The local path to the audio file to be uploaded.
        department (str): The department or topic associated with the file.

    Returns:
        None
    """
    try:
        file_name = os.path.basename(local_file)
        with open(local_file, 'rb') as f:
            logging.debug(f"Uploading file: {file_name}")
            ftp.storbinary(f'STOR {file_name}', f)
            logging.info(f"Uploaded {file_name} to FTP server")
            send_webhook(file_name, department)  # Send webhook after upload
    except Exception as e:
        logging.error(f"Failed to upload to FTP server: {e}")
        send_pushover_notification(f"Failed to upload to FTP server: {e}")

# -----------------------------------------------------------------------------
# Function: upload_to_ftp
# Description: Connects to the FTP server and uploads the file.
# -----------------------------------------------------------------------------
def upload_to_ftp(local_file, department):
    """
    Connects to the FTP server and uploads the specified audio file.

    This function handles the entire process of connecting to the FTP server 
    and uploading the audio file. It also triggers the webhook notification 
    after the upload is complete.

    Args:
        local_file (str): The local path to the audio file to be uploaded.
        department (str): The department or topic associated with the file.

    Returns:
        None
    """
    ftp = connect_to_ftp()
    if ftp:
        store_file(ftp, local_file, department)
        ftp.quit()

# -----------------------------------------------------------------------------
# Main Execution
# -----------------------------------------------------------------------------
def main():
    """
    Main function to process the audio file and handle errors.

    This function processes the command-line arguments, verifies the audio file 
    exists, and initiates the FTP upload and webhook notification process.
    """
    try:
        # Handle graceful shutdown on interrupt signals
        signal.signal(signal.SIGINT, graceful_shutdown)
        signal.signal(signal.SIGTERM, graceful_shutdown)

        # Log the arguments passed to the script
        logging.debug(f"Arguments passed to the script: {sys.argv}")

        if len(sys.argv) != 3:
            raise ValueError(f"Incorrect number of arguments passed to the script. Expected 3, got {len(sys.argv)}. Arguments: {sys.argv}")

        mp3_file = sys.argv[1]
        department = sys.argv[2]
        logging.info(f"Processing file: {mp3_file} for department: {department}")

        if os.path.isfile(mp3_file):
            upload_to_ftp(mp3_file, department)
        else:
            raise FileNotFoundError(f"File not found: {mp3_file}")

    except ValueError as ve:
        logging.error(f"ValueError encountered: {ve}")
        send_pushover_notification(f"ValueError encountered: {ve}")
    except FileNotFoundError as fnf_error:
        logging.error(f"FileNotFoundError encountered: {fnf_error}")
        send_pushover_notification(f"FileNotFoundError encountered: {fnf_error}")
    except Exception as e:
        logging.error(f"Unexpected error encountered: {e}")
        send_pushover_notification(f"Unexpected error encountered: {e}")

if __name__ == "__main__":
    main()
